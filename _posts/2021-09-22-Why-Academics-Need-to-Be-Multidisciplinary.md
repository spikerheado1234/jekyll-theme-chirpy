---
title: Why Academics Need To be Multidisciplinary 
date: 2021-09-22 19:05:21 +/-TTTT
categories: [Philosophical Musings, Problem Solving]
tags: interdisciplinary
---

Recently, I have been doing a lot of introspection on the decisions I have made in the past (I believe, the syndrome is called "senioritis" - where the abundance of time suddenly coerces me to actually... think for once in my educatiton). A lot of things are happening in my life to prompt this post. For one, I am, finally, applying to PhD programs which has forced me (at the tender age of 24) to come up with a coherent long term research goal for the next part of my career. For another, there has been a sudden interest in Computer Science across the globe, the intake within my college has itself quadrupled and with the fresh influx of new faces, a lot of questions are being asked of the form "I feel if I don't study at least 10 courses in machine learning, supplanted by 5 courses in algorithms, I won't be able to get into google and my life will be over". 

There seems to be a disparity in my PhD application process, the questions being asked by my juniors and my lived experiences. The former two are demanding hyper-specialisation from the get go when starting college, yet the latter has shown me quite the opposite.

So, queue Senior who has too much time for himself, I decided to make this blog post about my experiences and how they have viscerally shaped my outlook in convincing me that an interdisciplinary, *broad* based education, rather than a narrowly specialised education, seems to be an equally viable approach in building good computer scientists, researchers and problem solvers. 

I want to anchor this post in a research project I worked on some time ago. The project was on Automatic Program Repair by leveraging deep learning. I worked on this under Professor Lin Tan at Purdue University (a brilliant lab that does amazing research, check it out [here](https://www.cs.purdue.edu/homes/lintan/students.html)). 

Developers spend most of their time fixing annoying bugs. You can imagine, especially for really large projects, how this would bottleneck the entire development process. So the lab's brilliant idea was to, shockingly, apply deep learning to *automatically fix programs* (queue ominous music foreshadowing the rise of skynet and the impending demise of the human populace). Though the project seems to come out straight from a sci-fi novel, there is a surprising amount of research in this
area. We investigated an architecture called Neural-Machine-Translation, developed by some folks at Google in managing Google translate, and how it can be applied to translate buggy lines of source code, in their context, into semantically correct patches. 

Now, the issue with the above approach is that when we translate from Natural Language A to Natural Language B, what we can do if we use the NMT architecture is 
